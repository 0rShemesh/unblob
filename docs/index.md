# About

## What is unblob?

unblob is an _accurate, fast, and easy-to-use_ **extraction suite**. It parses
unknown binary blobs for more than 30 different _archive, compression, and
file-system formats_, **extracts** their **content recursively**, and **carves**
out **unknown chunks** that have not been accounted for.

Unblob is _free to use_, licensed with the _MIT license_, it has a
[Command Line Interface](guide.md#command-line-interface) and
can be used as a Python library.
This turns unblob into the perfect companion for extracting, **analyzing**, and
**reverse engineering firmware images**.

Unblob is a product of **OneKey** and used in production in our [OneKey Platform](https://onekey.com/).

## Demo

<script id="asciicast-Q71Vc6IrH0SUNoDA51jxHswKj" src="https://asciinema.org/a/Q71Vc6IrH0SUNoDA51jxHswKj.js" async></script>

## Why unblob?

One of the major challenges of embedded security analysis is the sound and safe
extraction of arbitrary firmware.

Specialized tools that can extract information from those firmwares already
exists, but we wanted something smarter that could identify both
**start offset** and **end offset** of a specific chunk
(e.g. filesystem, compression stream, archive, ...).

We **stick to the format standard** as much as possible when deriving these
offsets, and we clearly define what we want out of identified chunks (e.g., not
extracting meta-data to disk, padding removal). This strategy helps us feed
known valid data to extractors and **precisely identify** chunks, turning
unknown unknowns into known unknowns.

Given the **modular design** of unblob and the ever expanding repository of
[supported formats](formats.md), unblob could be used in areas outside of
embedded security such as data recovery, memory forensics, or malware analysis.

## Our Objectives

unblob has been developed with the following objectives in mind:

- **Accuracy** - chunk start offsets are identified using battle tested rules,
  while end offsets are computed according to the format's standard without
  deviating from it. We minimize false positives as much as possible by
  validating header structures and discarding overflowing chunks.

- **Security** - unblob does not require elevated privileges to run. It's
  heavily tested and has been [fuzz
  tested](https://github.com/onekey-sec/unblob/issues?q=label%3Afuzzing+)
  against a large corpus of files and firmware images. We rely on up-to-date
  third party dependencies that are
  [locked](https://github.com/onekey-sec/unblob/blob/main/poetry.lock) to limit
  potential supply chain issues. We use safe extractors that we audited and
  fixed where required (see [path traversal in
  ubi_reader](https://github.com/onekey-sec/ubi_reader/commit/4a81f3f0a714bb83d6ee71db09b7748619fa9fb7),
  [path traversal in
  jefferson](https://github.com/onekey-sec/jefferson/commit/53b3f2fc34af0bb32afbcee29d18213e61471d87),
  [integer overflow in Yara](https://github.com/VirusTotal/yara/pull/1615)).

- **Extensibility** - unblob exposes an API that can be used to write custom
  [format handlers](development.md#writing-handlers) and
  [extractors](development.md#writing-extractors) in no time.

- **Speed** - we want unblob to be blazing fast, that's why we use
  multi-processing by default, make sure to write efficient code, use
  memory-mapped files, and use [Hyperscan](https://github.com/intel/hyperscan)
  as high-performance matching library. Computation intensive functions are
  written in [Rust](https://github.com/onekey-sec/unblob/tree/main/rust) and
  called from Python using specific bindings.

## How does it work?

unblob identifies known and unknown chunks of data within a file:

- **known chunks** are identified by finding the start offset using a search
  rule, and the end offset is computed based on the format standard. **Unknown
  chunks** represents unidentified chunks of data before, after, or between
  known chunks. Unknown chunks composed of known content (e.g., null padding,
  `0xFF` padding) are auto-identified and reported as such.

- unblob will **carve** out known chunks to disk and perform the **extraction**
  phase using the extractor assigned to a given handler. It will then walk the
  extracted content, looking for chunks in extracted files.

- report on metadata can be generated by unblob, providing detailed
  information about identified chunks (format, offsets, size, entropy) and their
  extracted content if available (ownership, permissions, timestamps, ...).

## Used technologies

- Unblob is written in [Python](https://www.python.org/).
- For quickly searching binary patterns in files, we use [Hyperscan](https://www.hyperscan.io/).
- For extracting recognized formats, we use all kinds of different [Extractors](extractors.md).
- For ELF analysis, we are using [LIEF](https://lief-project.github.io/) with
  it's [Python bindings](https://pypi.org/project/lief/).
- For CPU-intensive tasks (e.g. entropy calculation), we use
  [Rust](https://www.rust-lang.org/) to speed thing up.
- For the pretty Command Line Interface, we are using the
  [Click library](https://click.palletsprojects.com/).
- For structured logging, we are using the
  [structlog library](https://www.structlog.org/).

- For development and testing tools, see the [Development](development.md) page.

## License

Unblob is licensed under the permissive [MIT license](../LICENSE), so you can use it without
restrictions.
